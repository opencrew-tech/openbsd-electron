MODPNPM_DIST=		npm_modules

MODPNPM_TARGETS?=	${WRKSRC}
MODPNPM_LOCKS?=		${MODPNPM_TARGETS:=%/pnpm-lock.yaml}

# XXX INCLUDES/EXCLUDES feature looks useless for now
MODPNPM_INCLUDES?= 	# include modules
MODPNPM_EXCLUDES?= 	# exclude modules

# pnpm overrides, https://pnpm.io/package_json#pnpmoverrides
# note you likely need MODPNPM_GEN_UPDATE/INSTALL
MODPNPM_GEN_OVERRIDES?=

# modpnpm-gen-modules helpers : empty/no, * or package@version
# run pnpm update, example esbuild@x.y.z
MODPNPM_GEN_UPDATE?=	No
# run pnpm install, example @swc/wasm@x.y.z
MODPNPM_GEN_INSTALL?=	No

MODPNPM_LOCKFILES?=	package.json pnpm-lock.yaml
MODPNPM_PATCHORIG?=	.orig.modpnpm

.if ${NO_BUILD:L} == "no"
MODPNPM_BUILDDEP?=	Yes
MODPNPM_BUILD?=		Yes
.else
MODPNPM_BUILDDEP?=	No
MODPNPM_BUILD?=		No
.endif

# by default there is no reason a port need a package manager to run itself
MODPNPM_RUNDEP?=	No

.if ${NO_TEST:L} == "no"
MODPNPM_TESTDEP?=	Yes
MODPNPM_TEST?=		Yes
.else
MODPNPM_TESTDEP?=	No
MODPNPM_TEST?=		No
.endif

# install with npm from pre-built package (bundled dependencies)
MODPNPM_INSTALL?=	Yes
MODPNPM_INSTALL_DIR?=	lib/node_modules

# where package are saved during build, used for both build/install
MODPNPM_PACKAGES?=	${WRKDIR}/packages

# XXX duplicate with modnpm
# to run node-gyp in custom build
MODPNPM_NODE_MODULES=${LOCALBASE}/lib/node_modules/npm
MODPNPM_GYP_BIN=${MODPNPM_NODE_MODULES}/node_modules/node-gyp/bin/node-gyp.js

# home needed for pnpm store, sync with modpnpm-gen-vendor
PORTHOME?=	${WRKDIR}/vendor

# without modules.inc, default vendor filename, see modpnpm-gen-vendor
MODPNPM_VENDOR?=	${PKGNAME}${REVISION:%=.%}-vendor.tgz

MODPNPM_REBUILD_ENV?=	npm_config_nodedir=${LOCALBASE}
MODPNPM_ENV?=		${MODPNPM_REBUILD_ENV} TMP=${WRKDIR}/tmp CI=true
MODPNPM_BIN?=		pnpm
MODPNPM_CMD?=		${SETENV} ${MAKE_ENV} ${MODPNPM_ENV} ${MODPNPM_BIN}
MODPNPM_ARGS?=		--verbose -dd --offline

SITES.pnpm?=		https://registry.npmjs.org/

# see post-extract
EXTRACT_CASES+=		${MODPNPM_DIST}/*) ;;

.if ${MODPNPM_BUILDDEP:L} == "yes"
BUILD_DEPENDS+=		devel/pnpm # depends on lang/node which include npm
.endif
.if ${MODPNPM_RUNDEP:L} == "yes"
RUN_DEPENDS+=		devel/pnpm
.endif
.if ${MODPNPM_TESTDEP:L} == "yes"
TEST_DEPENDS+=		devel/pnpm
.endif

.if ${MODPNPM_INSTALL:L} == "yes" && ${MODPNPM_BUILD:L} != "yes"
ERRORS += "Fatal: MODPNPM_BUILD=yes needed for MODPNPM_INSTALL to work"
.endif

MODPNPM_post-extract += \
	mkdir -p ${PORTHOME} ; \
	mkdir -p ${WRKDIR}/tmp ; \
	for _target in ${MODPNPM_TARGETS} ; do \
		cd $${_target} ;
# backup lock files
.for _LOCK in ${MODPNPM_LOCKFILES}
MODPNPM_post-extract += \
		[ -f ${_LOCK}${MODPNPM_PATCHORIG} ] || \
			[ -f ${_LOCK} ] && \
			cp ${_LOCK}{,${MODPNPM_PATCHORIG}} ;
.endfor
.if ${MODPNPM_INSTALL:L} == "yes"
# Pnpm install -g looks harder to work with, we have to populate global store
# the same way we do for local store but excluding unneeded package, then we may
# be able to install offline. Anyway, do we want a global store in usr/local ?
# To overcome this issue we will pack hoisted (& bundled) dependencies, then use
# npm to perform final installation step as a standalone package, offline.
# See modpnpm-gen-modules for package.json bundledDependencies (use jq).
# XXX no .orig, add pnpm-workspace.yaml into MODPNPM_LOCKFILES ?
# XXX use --node-linker=hoisted instead (not documented ?)
MODPNPM_post-extract += \
		grep 'nodeLinker' pnpm-workspace.yaml 2>/dev/null && \
		sed -i 's/nodeLinker.*/nodeLinker: hoisted/' \
			pnpm-workspace.yaml || \
		echo 'nodeLinker: hoisted' >> pnpm-workspace.yaml ;
.endif
MODPNPM_post-extract += \
		cd - >/dev/null ; \
	done ;

.if empty(_GEN_MODULES)

# Override locks with those generated by modpnpm-gen-modules
MODPNPM_post-extract += \
	for _target in $$(echo "${MODPNPM_TARGETS}"); do \
		cd $${_target} ; \
		echo "MODPNPM: update $${_target}" ; \
		_target=$${_target}/ ; \
		_prefix=$$(echo "$${_target\#\#"${WRKSRC}/"}" | tr '/' '_') ;
.for _LOCK in ${MODPNPM_LOCKFILES}
MODPNPM_post-extract += \
		[ -f ${FILESDIR}/modpnpm_$${_prefix}${_LOCK} ] && \
			cp ${FILESDIR}/modpnpm_$${_prefix}${_LOCK} ${_LOCK} ;
.endfor
MODPNPM_post-extract += \
		cd - >/dev/null ; \
	done ;

# import distfiles in store for pnpm use offline
MODPNPM_post-extract += \
	rm -f ${WRKDIR}/store.list ; \
	for _module in $$(echo "${MODPNPM_PKGS}"); do \
		_id=$${_module%;*} ; _pkg=$${_module\#*;} ; \
		echo "$${_id}|${DISTDIR}/${MODPNPM_DIST}/$${_pkg}" \
			>> ${WRKDIR}/store.list ; \
	done ; \
	[ -f ${WRKDIR}/store.list ] && \
		echo "MODPNPM: store add ***" && \
		cd ${WRKDIR} && cat store.list | \
		xargs ${MODPNPM_CMD} store add ;

# install node_modules files only then patch and rebuild during pre-build
MODPNPM_post-extract += \
	for _target in ${MODPNPM_TARGETS}; do \
		echo "MODPNPM: install $${_target}" ; \
		cd $${_target} && ${MODPNPM_CMD} install ${MODPNPM_ARGS} \
			--frozen-lockfile --ignore-scripts \
			${MODPNPM_OMITOPTIONAL:L:S/yes/--no-optional/:S/no//} \
			${MODPNPM_OMITDEV:L:S/yes/--prod/:S/no//} ; \
		cd - >/dev/null ; \
	done ;

.endif # empty(_GEN_MODULES)

# XXX monorepo needs special care ? (rebuild -r in doubt ?)
MODPNPM_PREBUILD_TARGET=\
	for _target in $$(echo "${MODPNPM_TARGETS}"); do \
		echo "MODPNPM: rebuild $${_target}" ; \
		cd $${_target} && ${MODPNPM_CMD} rebuild -dd ; \
	done

# XXX monorepo needs special care ? (pack -r in doubt ?)
MODPNPM_BUILD_TARGET=\
	for _target in $$(echo "${MODPNPM_TARGETS}"); do \
		echo "MODPNPM: pack $${_target}" ; \
		cd $${_target} && ${MODPNPM_CMD} pack -dd \
			--out ${MODPNPM_PACKAGES}/%s.tgz ; \
	done

# XXX pnpm deploy alternative ?
MODPNPM_INSTALL_TARGET=\
	${INSTALL_DATA_DIR} ${PREFIX}/${MODPNPM_INSTALL_DIR} ; \
	${SETENV} ${MAKE_ENV} npm install -dd --exclude=dev --global --offline \
		--prefix=${PREFIX} --install-links ${MODPNPM_PACKAGES}/*.tgz ; \
	find ${PREFIX}/${MODPNPM_INSTALL_DIR} -type f \( \
		-name '*${MODPNPM_PATCHORIG}' \
		-or -name '*${PATCHORIG}' \
		-or -name '*.core' \
		\) -exec rm {} \; ;

MODPNPM_TEST_TARGET=\
	for _target in $$(echo "${MODPNPM_TARGETS}"); do \
		echo "MODPNPM: test $${_target}" ; \
		cd $${_target} && ${MODPNPM_CMD} test ; \
	done

.if !target(pre-build)
pre-build:
	@${MODPNPM_PREBUILD_TARGET}
.endif

.if !target(do-build) && ${MODPNPM_BUILD:L} == "yes"
do-build:
	@${MODPNPM_BUILD_TARGET}
.endif

.if !target(do-install) && ${MODPNPM_INSTALL:L} == "yes"
do-install:
	@${MODPNPM_INSTALL_TARGET}
.endif

.if !target(do-test) && ${MODPNPM_TEST:L} == "yes"
do-test:
	@${MODPNPM_TEST_TARGET}
.endif

.if !target(modpnpm-diff)
modpnpm-diff:
.for _LOCK in ${MODPNPM_LOCKFILES}
	@for _target in $$(echo "${MODPNPM_TARGETS}"); do \
		cd ${FILESDIR} ; \
		_target=$${_target}/ ; \
		_prefix=$$(echo "$${_target##"${WRKSRC}/"}" | tr '/' '_') ; \
		if [[ $${_target}${_LOCK} == *.json ]] ; then \
			[ -f $${_target}${_LOCK}${MODPNPM_PATCHORIG} ] && \
			jq '.' $${_target}${_LOCK}${MODPNPM_PATCHORIG} | \
			diff -uN - modpnpm_$${_prefix}${_LOCK} || true ; \
		else \
			[ -f $${_target}${_LOCK}${MODPNPM_PATCHORIG} ] && \
			diff -uN $${_target}${_LOCK}${MODPNPM_PATCHORIG} \
				modpnpm_$${_prefix}${_LOCK} || true ; \
		fi ; \
	done
.endfor
.endif

# OpenBSD use system node, ignore any version requirement
MODPNPM_gen-lockfiles += \
	jq 'del(.engines,.packageManager)' package.json \
		> tmp.json && mv {tmp,package}.json ;

# Setup overrides customisation before modpnpm-gen-lockfiles (w/patches), ex:
# MODPNPM_GEN_OVERRIDES =	"foo":"npm:foo@x.y.z" "bar":"npm:@cutom/bar"
.for _modpnpm_override in ${MODPNPM_GEN_OVERRIDES}
_MODPNPM_OVERRIDES:=${_modpnpm_override:%=%, }${_modpnpm_override}
.endfor
.if !empty(_MODPNPM_OVERRIDES)
MODPNPM_gen-lockfiles += \
	jq '.pnpm.overrides += {${_MODPNPM_OVERRIDES}}' package.json \
		> tmp.json && mv {tmp,package}.json ;
.endif

.if ${MODPNPM_INSTALL:L} == "yes"
# See post_extract for pnpm-workspace.yaml nodeLinker
MODPNPM_gen-lockfiles += \
	jq '.bundledDependencies = true' package.json \
		> tmp.json && mv {tmp,package}.json ;
.endif

# skip generating modules.inc, vendor store in $HOME ($WRKDIR/vendor)
_MODPNPM_VENDOR?=No
# default env for generating lockfiles, modules.inc or vendor store
_MODPNPM_TMP?=/tmp
_MODPNPM_GEN_VAR?= -D _GEN_MODULES BUILD_USER=$$(whoami) WRKOBJDIR=$${t}
_MODPNPM_GEN_DIR?=$$(mktemp -d ${_MODPNPM_TMP}/modpnpm.XXXXXXXXXX)

.if !target(_modpnpm-gen-modules)
_modpnpm-gen-modules:
# run with custom BUILD_USER & WRKOBJDIR
	@for _target in $$(echo "${MODPNPM_TARGETS}"); do \
		echo "MODPNPM: fix lock $${_target}" ; \
		cd $${_target} ; \
		${MODPNPM_gen-lockfiles} \
	done
.if !empty(MODPNPM_GEN_UPDATE) && ${MODPNPM_GEN_UPDATE:L} != "no"
	@for _target in $$(echo "${MODPNPM_TARGETS}"); do \
		echo "MODPNPM: update ${MODPNPM_GEN_UPDATE} $${_target}" ; \
		cd $${_target} && ${MODPNPM_CMD} update \
			${MODPNPM_GEN_UPDATE} --lockfile-only ; \
	done
.endif
.if !empty(MODPNPM_GEN_INSTALL) && ${MODPNPM_GEN_INSTALL:L} != "no"
	@for _target in $$(echo "${MODPNPM_TARGETS}"); do \
		echo "MODPNPM: add ${MODPNPM_GEN_INSTALL} $${_target}" ; \
		cd $${_target} && ${MODPNPM_CMD} install \
			${MODPNPM_GEN_INSTALL} --lockfile-only ; \
	done
.endif
	@[ -f ${.CURDIR}/modules.inc ] && \
		mv ${.CURDIR}/modules.inc{,.orig} || true
.if ${_MODPNPM_VENDOR:L} == "no"
	@echo "MODPNPM: generate modules.inc" ; \
	echo "#INCLUDES=${MODPNPM_INCLUDES}" >> ${.CURDIR}/modules.inc ; \
	echo "#EXCLUDES=${MODPNPM_EXCLUDES}" >> ${.CURDIR}/modules.inc ; \
	${_PERLSCRIPT}/modpnpm-gen-modules \
		${MODPNPM_INCLUDES:='-i %'} \
		${MODPNPM_EXCLUDES:='-x %'} \
		${MODPNPM_LOCKS} >> ${.CURDIR}/modules.inc && \
	echo "=> ${.CURDIR}/modules.inc"
.endif
	@mkdir -p ${FILESDIR}
.for _LOCK in ${MODPNPM_LOCKFILES}
	@cd ${FILESDIR} ; \
	for _target in $$(echo "${MODPNPM_TARGETS}"); do \
		echo "MODPNPM: bundle lock $${_target}" ; \
		_target=$${_target}/ ; \
		_prefix=$$(echo "$${_target##"${WRKSRC}/"}" | tr '/' '_') ; \
		[ -f modpnpm_$${_prefix}${_LOCK} ] && \
			cp modpnpm_$${_prefix}${_LOCK}{,.orig} ; \
		[ -f $${_target}${_LOCK} ] && \
			cp $${_target}${_LOCK} modpnpm_$${_prefix}${_LOCK} && \
			echo "=> ${FILESDIR}/modpnpm_$${_prefix}${_LOCK}" ; \
	done
.endfor
.endif

.if !target(modpnpm-gen-modules)
modpnpm-gen-modules:
	@which jq >/dev/null
	@t=${_MODPNPM_GEN_DIR} && \
	echo "MODPNPM: extract in $${t} as $$(whoami)" && \
	make ${_MODPNPM_GEN_VAR} extract && \
	echo "MODPNPM: gen-modules in $${t} as $$(whoami)" && \
	make ${_MODPNPM_GEN_VAR} _modpnpm-gen-modules && \
	echo "MODPNPM: rm $${t}..." && \
	[ -d "$${t}" ] && rm -rf $${t} && \
	echo "MODPNPM: rm $${t}, done." || \
	echo "MODPNPM: FAIL, rm $${t} or try again with _MODPNPM_GEN_DIR=$${t}"
.endif

.if !target(_modpnpm-gen-vendor)
_modpnpm-gen-vendor:
# run with custom BUILD_USER & WRKOBJDIR
	@for _target in ${MODPNPM_TARGETS}; do \
		echo "MODPNPM: install force $${_target}" ; \
		cd $${_target} && ${MODPNPM_CMD} install --force \
			--frozen-lockfile --ignore-scripts \
			${MODPNPM_OMITOPTIONAL:L:S/yes/--no-optional/:S/no//} \
			${MODPNPM_OMITDEV:L:S/yes/--prod/:S/no//} ; \
		cd - >/dev/null ; \
	done ;
	@cd ${WRKDIR} && \
	tar -Rczf ${.CURDIR}/${MODPNPM_VENDOR} \
		vendor/.local/share/pnpm/store && \
	echo "=> ${.CURDIR}/${MODPNPM_VENDOR}"

.endif

# If in trouble, use vendor pre-made store
.if !target(modpnpm-gen-vendor)
modpnpm-gen-vendor:
	@make _MODPNPM_VENDOR=Yes modpnpm-gen-modules
	@t=${_MODPNPM_GEN_DIR} && \
	echo "MODPNPM: extract in $${t} as $$(whoami)" && \
	make ${_MODPNPM_GEN_VAR} extract && \
	echo "MODPNPM: gen-vendor in $${t} as $$(whoami)" && \
	make ${_MODPNPM_GEN_VAR} _modpnpm-gen-vendor && \
	echo "MODPNPM: rm $${t}..." && \
	[ -d "$${t}" ] && rm -rf $${t} && \
	echo "MODPNPM: rm $${t}, done." || \
	echo "MODPNPM: FAIL, rm $${t} or try again with _MODPNPM_GEN_DIR=$${t}"
.endif